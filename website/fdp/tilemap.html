<!doctype html>
<script src=f3-bits.js></script>
<link rel=stylesheet href=../style.css>
<link rel=stylesheet href=./style2.css>

<a href=home.html>Back</a>
<h1>Tilemaps</h1>

<p>There are four tilemap layers, numbered 0 to 3.&nbsp;
	Each is a 32×32 (or 64×32 if Extend Mode is enabled) grid of tiles, represented by an array of 32-bit values.
	
<p>Each tile references a 16×16px texture, defined in <abbr>rom</abbr>, with up to 64 colors (including transparent) per tile.&nbsp;
	Tilemaps can be scaled on both axes, with a range of 50.2% to infinity vertically, and 100% to 25600% horizontally.
	
	<todo>describe how scrolling works (e.g. units and such) and how it is affected by scaling. give formulas for positions etc.</todo>
	
<h2>Scrolling and Scaling</h2>
<p>
	We can calculate which pixel of the tilemap will be displayed at a given position on-screen.<br>
	
	For the X axis, we use:
	<math display=block>
		<mrow>
		<mi>Xglobal</mi>
		<mo>+</mo>
		<msub>
			<mi>Xadjust</mi>
			<mi>y</mi>
		</msub>
		<mo>+</mo>
		<mn>18</mn>
		<mo>+</mo>
		<mo stretchy=false>(</mo><mi>x</mi><mo>+</mo><mn>22</mn><mo>-</mo><mn>4</mn><mo>&sdot;</mo><mi>tnum</mi><mo stretchy=false>)</mo><mo>&sdot;</mo><msub><mi>Xzoom</mi><mi>y</mi></msub>
		</mrow>
	</math>
	Where:<br>
	<var>x</var> is the current x screen position (in screen pixels)<br>
	<var>y</var> is the current scanline<br>
	<var>tnum</var> is the tilemap number<br>
	<var>Xglobal</var> is the tilemap's X Global Scroll (in texture pixels)<br>
	<var>Xadjust</var> is its X Scroll Adjust (in texture pixels) on a given scanline<br>
	<var>Xzoom</var> is its X Zoom (in texture pixels per screen pixel) on a given scanline<br>
	
<p>
	The Y axis is more complicated, because the offset of each row depends on the rows above.<br>
	Each tilemap has a "Y Scroll Accumulator", which is in units of texture pixels (with a precision of 1/128).<br>
	At the beginning of each scanline, if Y Scroll Sync is set (usually on scanline 0), each tilemap's Y Scroll Accumulator is set from its Y Global Scroll register. Otherwise, the accumulator is incremented by the Y Zoom Register. (note that this happens at the beginning of the scanline, not the end)<br>
	Then, the scanline is rendered.&nbsp; The source row for each tilemap is determined by its Y Scroll Accumulator + Y Scroll Adjust.<br>
	(note that Y Scroll Accumulator is not reset automatically, and carries over from the previous frame until Scroll Sync is set)
	
<p>Thus, to calculate the y source position, we can use:
	<math display=block>
		<mrow>
			<mrow>
				<mi>Yglobal</mi>
			</mrow>
			<mo>+</mo>
			<msub>
				<mi>Yadjust</mi>
				<mi>y</mi>
			</mrow>
			<mo>+</mo>
			<mrow>
				<munderover>
					<mo>&sum;</mo>
					<mrow><mi>j</mi><mo>=</mo><mi>sync</mi></mrow>
					<mrow><mi>y</mi></mrow>
				</munderover>
				<msub><mi>Yzoom</mi><mi>j</mi></mrow>
				<mo>&sdot;</mo>
				<mi>1</mi><mspace width=thinmathspace /><mi mathvariant=normal>screen pixel</mi>
			</mrow>
		</mrow>
	</math>
	
	Where:<br>
	<var>y</var> is the current scanline<br>
	<var>Yglobal</var> is the tilemap's Y Global Scroll (in texture pixels)<br>
	<var>Yadjust</var> is its Y Scroll Adjust (in texture pixels) on a given scanline<br>
	<var>Yzoom</var> is its Y Zoom (in texture pixels per screen pixel) on a given scanline<br>
	<var>sync</var> is the most recent scanline on which Scroll Sync was set (usually scanline 0).<br>
	Note that this assumes <var>y</var> ≥ <var>sync</var>.
	<!--&sum;&thinsp;<sub>j&thinsp;&isin;&thinsp;[sync,y)</sub>(Yzoom<sub>j</sub>)-->
<figure class=f3-struct>
	<h1>Tile Data</h1>
	<h2>Address (normal)</h2>
	<f3-bits>&ctdot;,0,0,1,0,num:3,y:5,x:5,-:2</f3-bits>
	<h2>Address (extend mode)</h2>
	<f3-bits>&ctdot;,0,0,1,num:3,y:5,x:6,-:2</f3-bits>
	<dl class=bits>
		<dt>num<dd>tile data number (0-5)
			<dl>
				<dt><var>N</var> (0-3)<dd>Tilemap <var>N</var>: normal data
				<dt>4<dd>Tilemap 2: alternate data
				<dt>5<dd>Tilemap 3: alternate data
			</dl>
		<dt>y<dd>tile y index (0-31)
		<dt>x<dd>tile x index (0-31 or 0-63)
	</dl>
	<h2>Data[0]</h2>
	<f3-bits>v,h,tex2:2,bpp:2,as,palette:9</f3-bits>
	<dl class=bits>
		<dt>palette<dd>palette id (0-511)
		<dt>as<dd>Alpha Select<br>(note how this is stored per-tile rather than per-scanline)
		<dt>bpp<dd>texture bit planes (bits per pixel select)<todo>better wording for bpp</todo>
			<dl>
				<dt>0<dd>4bpp (16-color)
				<dt>1<dd>5bpp (32-color)
				<dt>2<dd>?
  				<dt>3<dd>6bpp (64-color)
			</dl>
		<dt>tex2<dd>Texture Id (upper 2 bits)
		<dt>h<dd><dl compact><dt>1<dd>horizontal flip</dl>
		<dt>v<dd><dl compact><dt>1<dd>vertical flip</dl>
	</dl>
	<h2>Data[1]</h2>
	<f3-bits>texture:16</f3-bits>
	<dl class=bits>
		<dt>texture<dd>Texture Id (lower 16 bits)<br>
			<div class=mathbox>Texture Id = texture | tex2<<16</div><br>
	</dl>
</figure>

<figure class=f3-struct>
	<h1>Scroll Registers 0-3</h1>
	<h2>Address</h2>
	<f3-bits>&ctdot;,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,num:2,-</f3-bits>
	<dl class=bits>
		<dt>num<dd>tilemap number <var>N</var> (0-3)
	</dl>
	<h2>Data</h2>
	<f3-bits>ipart:10,fpart:6</f3-bits>
	<dl class=bits>
		<dt>ipart<dd>Tilemap <var>N</var>: X Global Scroll (integer part; 0-1024)<br>
		<dt>fpart<dd>Tilemap <var>N</var>: X Global Scroll (negative fractional part; in steps of 1/64)<br>
			<div class=mathbox>X Global Scroll (in texture pixels) = ipart &minus; fpart/64</div>
	</dl>
</figure>

<figure class=f3-struct>
	<h1>Scroll Registers 4-7</h1>
	<h2>Address</h2>
	<f3-bits>&ctdot;,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,num:2,-</f3-bits>
	<dl class=bits>
		<dt>num<dd>tilemap number <var>N</var> (0-3)
	</dl>
	<h2>Data</h2>
	<f3-bits>ipart:9,fpart:7</f3-bits>
	<dl class=bits>
		<dt>ipart<dd>Tilemap <var>N</var>: Y Global Scroll (integer part; 0-511)<br>
		<dt>fpart<dd>Tilemap <var>N</var>: Y Global Scroll (fractional part; in steps of 1/128)<br>
			<div class=mathbox>Y Global Scroll (in texture pixels) = ipart + fpart/128</div>
			<br><todo>is this negative like x scroll?</todo>
	</dl>
</figure>

<figure class=f3-struct>
	<h1>Scroll Register 15</h1>
	<h2>Address</h2>
	<f3-bits>&ctdot;,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,-</f3-bits>
	<h2>Data</h2>
	<f3-bits>#:8,ex,#:7</f3-bits>
	<dl class=bits>
		<dt>ex<dd>Tilemaps: Extend Mode
			<dl><dt>0<dd>32×32 tilemaps<dt>1<dd>64×32 tilemaps</dl>
	</dl>
</figure>

<figure class=f3-struct>
	<h1>Line Registers 0.<var>N</var> "4400" "4600"</h1>
	<div>Note: supported on tilemaps 2 and 3 only.<todo>typeset this better</todo></div>
	<h2>Data</h2>
	<f3-bits>#:6,alt,yscroll:9</f3-bits>
	<dl class=bits>
		<dt>yscroll<dd>Tilemap <var>N</var>: Y Scroll Adjust (integer; 0-511)<br>
			<div class=mathbox>Y Scroll Adjust (in texture pixels) = yscroll</div>
		<dt>alt<dd>Tilemap <var>N</var>: Alternate Tile Data<dl><dt>0<dd>normal<dt>1<dd>use alternate tile data</dl>
	</dl>
</figure>

<figure class=f3-struct>
	<h1>Line Register 2.0 "6000"</h1>
	<h2>Data</h2>
	<f3-bits>#:4,y,#:11</f3-bits>
	<dl class=bits>
		<dt>y<dd>Tilemaps: Y Scroll Sync
			<dl><dt>1<dd>initialize y scroll accumulators from the y global scroll registers</dl>(basically: you should set this on the first scanline, or the tilemaps' y positions will be unstable)
	</dl>
</figure>

<figure class=f3-struct>
	<h1>Line Register 2.2 "6400"</h1>
	<h2>Data</h2>
	<f3-bits>#:12,p<sub>3</sub>,p<sub>2</sub>,p<sub>1</sub>,p<sub>0</sub></f3-bits>
	<dl class=bits>
		<dt>p<sub>N</sub><dd>Tilemap <var>N</var>: Mosaic Enable
	</dl>
</figure>

<figure class=f3-struct>
	<h1>Line Registers 4.<var>N</var> "8000" "8200" "8400" "8600"</h1>
	<h2>Data</h2>
	<f3-bits>xzoom:8,yzoom:8</f3-bits>
	<dl class=bits>
		<dt>yzoom<dd>Tilemap <var>N</var>*: Y Zoom<br>
			*bug: tilemaps 1 and 3 have their vertical zooms swapped<br>
			<div class=mathbox>Y Zoom (in texture pixels per screen pixel) = yzoom / 128</div><br>
<!--			in units of: <div class=mathbox><math><mrow><mn>128</mn><mo>&InvisibleTimes;</mo><mo>(</mo><mfrac><mi>texture pixels</mi><mi>screen pixels</mi></mfrac><mo>)</mo></mrow></math></div><br>
			<div class=mathbox><math><mrow><mi>Y Zoom</mi><mtext>&nbsp;in&nbsp;</mtext><mfrac><mi>texture pixels</mi><mi>screen pixels</mi></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>128</mn></mfrac><mo>&InvisibleTimes;</mo><mi>vzoom</mi></mrow></math></div><br>-->
			Example scale factors: (in screen pixels per texture pixel)
			<dl><dt>$00<dd>∞×<dt>$40<dd>2.0×<dt>$80<dd>1.0×<dt>$C0<dd>0.667×<dt>$FF<dd>0.502×</dl>
		<dt>xzoom<dd>Tilemap <var>N</var>: X Zoom<br>
			<div class=mathbox>X Zoom (in texture pixels per screen pixel) = 1 &minus; xzoom / 256</div><br>
			Example scale factors: (in screen pixels per texture pixel)
			<dl><dt>$00<dd>1.0×<dt>$40<dd>1.333×<dt>$80<dd>2.0×<dt>$C0<dd>4.0×<dt>$FF<dd>256.0×</dl>
	</dl>
</figure>

<figure class=f3-struct>
	<h1>Line Registers 5.<var>N</var> "9000" "9200" "9400" "9600"</h1>
	<h2>Data</h2>
	<f3-bits>#:10,palette:6</f3-bits>
	<dl class=bits>
		<dt>palette<dd>Tilemap <var>N</var>: Palette Adjust (added to the palette of all tiles)
	</dl>
</figure>

<figure class=f3-struct>
	<h1>Line Registers 6.<var>N</var> "A000" "A200" "A400" "A600"</h1>
	<h2>Data</h2>
	<f3-bits>xscroll:16</f3-bits>
	<dl class=bits>
		<dt>xscroll<dd>Tilemap <var>N</var>: X Scroll Adjust<br>(same format as X Global Scroll)
	</dl>
</figure>

<figure class=f3-struct>
	<h1>Line Registers 7.<var>N</var> "B000" "B200" "B400" "B600"</h1>
	<h2>Data</h2>
	<f3-bits>bm:2,clip:10,prio:4</f3-bits>
	<dl class=bits>
		<dt>prio<dd>Tilemap <var>N</var>: Priority (0-15)
		<dt>clip<dd>Tilemap <var>N</var>: Clip Settings
		<dt>bm<dd>Tilemap <var>N</var>: Blend Mode<dl><dt>0<dd>A+B<dt>1<dd>A<dt>2<dd>B<dt>3<dd>none</dl>
	</dl>
</figure>

per-tilemap values:
- name | type | set per:
- x global scroll | texture pixels | frame
- y global scroll | texture pixels | frame
- y scroll accumulator | texture pixels | internal, per-scanline
- x scroll adjust | texture pixels | scanline
- y scroll adjust | texture pixels | scanline
- alternate tile data | boolean | scanline
- x zoom | texture pixels per screen pixel | scanline
- y zoom | texture pixels per screen pixel | scanline
- palette adjust | palette id | scanline

shared values:
- y scroll sync | boolean | scanline
- extend mode | boolean | frame

per-tile values:
- texture id | texture id
- palette id | palette id
- alpha select | alpha id (common setting but special, do we list it?)
- texture bpp | enum?
- x flip | boolean
- y flip | boolean

the register descriptors should say the name of the field they affect, and how to map the raw value into something we can use. e.g. how to map blend mode number to one of the enum values, or how to map x zoom to a value in texture pixels per screen pixels.
then, we should have a list of fields with their types and ranges/precisions and how they are used.  so tired...

(later)  ah but  idk maybe not. i mean, it's like.. we may as well use the registers AS our fields list. tbh. put the descs there

<h2>Scroll Register Settings</h2>
<h3>Global Scroll X</h3>
<h3>Global Scroll Y</h3>
<h3>Tilemap Extend Mode (shared)</h3>

<h2>Lineram Settings</h2>
<h3>X Scroll Adjust</h3>
<h3>Y Scroll Adjust (tilemaps 2 and 3 only)</h3>
<h3>Alternate Tile Data (tilemaps 2 and 3 only)</h3>
<h3>Y Scroll Sync (shared)</h3>
<h3>Zoom X</h3>
<h3>Zoom Y</h3>
<h3>Palette Adjust</h3>

<todo>the mathbox styling is nice but i think we should have like,  consistent styling for:
	- the formula for the value of an abstract field
   - other definitions of abstract fields 
	or i mean like, i want a consistent  "look over here, here is where an abstract field is being defined" box styling. whether it has a math equation or something else.
</todo>
