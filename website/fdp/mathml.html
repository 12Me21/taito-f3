<!doctype html>
<script src=f3-bits.js></script>
<link rel=stylesheet href=../style.css>
<link rel=stylesheet href=./style2.css>

ok so the overall flow of this should be
1: here is some pseudo code for how the y accumulator is updated
2: from this we can derive a high-level forumla (the integral one)

<p>
	Each tilemap has a "Y Source" accumulator, which is in units of texture pixels (with a precision of 1/128).<br>
	At the beginning of each scanline, if Scroll Sync is set (usually on scanline 0), each tilemap's Y Source is set from its Y Global Scroll register.<br>
	At the end of the scanline, each tilemap's Y Source is incremented by its Y Zoom register.
	

the source of a scanline, in texture pixels is given by:

ytpx(scanline) + y_scroll_adjust[scanline]

where ytpx(scanline) = {
y_global_scroll / 128, if scroll_sync[scanline] is set
ytpx(scanline-1) + y_zoom[scanline] / 128, otherwise 


the source of a scanline <var>y</var>, in texture pixels, is given by:

<math>
	<mrow><mi>acc</mi><mo>(</mo>y</mi><mo>)</mo><mo>+</mo><mi>y_scroll_adjust</mi><mo>[</mo><mi>scanline</mi><mo>]</mo></mrow>
</math>

where
<math display=block>
	<mrow>
		<msub><mi>acc</mi><mi>y</mi></msub>
		<mrow><mo>=</mo></mrow>
		<mrow>
			<mo>{</mo>
			<mtable columnalign="left left" rowspacing=".2em" columnspacing="1em" displaystyle="false">
				<mtr>
					<mtd><mi>Y Global Scroll</mi></mtd>
					<mtd><mtext>&nbsp;if&nbsp;</mtext><msub><mi>Sync</mi><mi>y</mi></msub><mtext>&nbsp;is set</mtext></mtd></mtr>
				<mtr>
					<mtd><msub><mi>acc</mi><mrow><mi>y</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>Y Zoom</mi><mrow><mi>y</mi><mo>-</mo><mn>1</mn></mrow></msub></mtd>
					<mtd><mtext>&nbsp;otherwise</mtext></mtd>
				</mtr>
			</mtable>
		</mrow>
	</mrow>
</math>
note: acc<sub>&minus;1</sub> refers to acc<sub>255</sub> of the previous frame, etc. the initial value is undefined.

	<math display=block>
		<mrow>
		<mi>X Global Scroll</mi>
		<mo>+</mo>
		<msub>
			<mi>X Scroll Adjust</mi>
			<mi>y</mi>
		</msub>
		<mo>+</mo>
		<mn>18</mn>
		<mo>+</mo>
		<mo stretchy=false>(</mo><mi>x</mi><mo>+</mo><mn>22</mn><mo>-</mo><mn>4</mn><mo>&sdot;</mo><mi>tnum</mi><mo stretchy=false>)</mo><mo>&sdot;</mo><msub><mi>X Zoom</mi><mi>y</mi></msub>
		</mrow>
	</math>

	<math display=block>
		<mrow>
			<msub>
				<mi>acc</mi>
				<mi>y</mi>
			</msub>
			<mo>+</mo>
			<msub>
				<mi>Y Scroll Adjust</mi>
				<mi>y</mi>
			</msub>
		</mrow>
	</math>
	
<p>Thus, to convert a screen y position (in screen pixels) <var>y</var> to a source y position within a tilemap (in texture pixels), we can use:
	<math display=block>
		<mrow>
			<mrow>
				<mi>global</mi>
			</mrow>
			<mo>+</mo>
			<mrow>
				<mi>adjust</mi>
				<mo stretchy=false>(</mo><mi>y</mi><mo stretchy=false>)</mo>
			</mrow>
			<mo>+</mo>
			<mrow>
				<msubsup>
					<mo>&int;</mo>
					<mrow style=width:1em;><msub><mi>y</mi><mi>sync</mi></msub></mrow>
					<mrow><mi>y</mi></mrow>
				</msubsup>
				<mrow>
					<mi>zoom</mi>
					<mo stretchy=false>(</mo><mi>n</mi><mo stretchy=false>)</mo>
				</mrow>
				<mspace width=thickmathspace></mspace>
				<mrow><mi>d</mi><mi>n</mi></mrow>
			</mrow>
		</mrow>
	</math>
	<details><summary>[Show] why is this an integral instead of a summation?</summary>
		Yes, it could be a Riemann sum with Δn = 1 screen pixel:
		<math display=block>
			<mrow>
				<munderover>
					<mo>&sum;</mo>
					<mrow><mi>j</mi><mo>=</mo><msub><mi>y</mi><mi>sync</mi></msub></mrow>
					<mrow><mi>y</mi><mo>&minus;</mo><mn>1</mn></mrow>
				</munderover>
				<mrow><mi>zoom</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow>
				<mo>&sdot;</mo>
				<mi>1</mi><mspace width=thinmathspace /><mi mathvariant=normal>screen pixel</mi>
			</mrow>
		</math>
		
	</details>
	
	Where:<br><var>global</var> is the tilemap's Global Scroll Y<br><var>adjust</var>(n) is its Scroll Adjust Y at a given screen y position<br><var>zoom</var>(n) is its Zoom Y at a given screen y position<br><var>y<sub>sync</sub></var> is the most recent scanline on which Scroll Sync was set (usually scanline 0).<br>
	Note that this assumes <var>y</var> ≥ <var>y<sub>sync</sub></var>.
	<br><todo>find a way to notate in the zoom field description that this has a scale factor of 128, as with global scroll</todo>
	
<p>
	<math  display=block>
		<mrow>
				<munderover>
					<mo movablelimits="false">&int;</mo>
					<msub><mi>y</mi><mi>sync</mi></msub>
					<mi>y</mi>
				</munderover>
			<mi>zoom</mi>
			<mo form="prefix" stretchy="false">(</mo>
			<mi>y</mi>
			<mo form="postfix" stretchy="false">)</mo>
		</mrow>
	</math>
	
	<style>
		sub-sup {
			display: inline-grid;
			grid-template: 
				". sign top" 1em
				"before sign mid" 1em
				". sign bot" 1em
			/ 0px max-content max-content;
		}
		sub-sup::before {
			grid-area: before;
			content: "";
		}
		sub-sup > :nth-child(1) { grid-area: sign; align-self: center; font-size: 3em; }
		sub-sup > :nth-child(2) { grid-area: bot; font-size: 0.75em; align-self: flex-end;}
		sub-sup > :nth-child(3) { grid-area: top; font-size: 0.75em; align-self: flex-start; }
		sub-sup > :nth-child(4) { grid-area: mid; align-self: baseline; }
	</style>
<div>
	 global + adjust(⌊y⌋) + <sub-sup><span>∫</span><span>y<sub>sync</sub></span><span>y</span><span>zoom(⌊n⌋) dn</span></sub-sup>
</div>
	
<p>test
	<math display=block><mrow>
		<mrow>
			<mo>(</mo><mi>U</mi><mo>·</mo><msub><mi>invert</mi><mi>global</mi></msub><mo>)</mo>
		</mrow>
		<mo>⊕</mo>
		<mrow>
			<munderover><mo>⋃</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>3</mn></munderover>
		</mrow>
		<mo>(</mo>
		<mrow>
			<mrow>
				<mo>[</mo>
				<msub><mi>left</mi><mi>i</mi></msub>
				<mo>,</mo>
				<msub><mi>right</mi><mi>i</mi></msub>
				<mo>)</mo>
			</mrow>
			<mo>⊕</mo>
			<mrow>
				<mo>(</mo><mi>U</mi><mo>·</mo><msub><mrow><mo>&not;</mo><mi>mode</mi></mrow><mi>i</mi></msub><mo>)</mo>
			</mrow>
			<mo>·</mo>
			<msub><mrow><mi>enable</mi></mrow><mi>i</mi></msub>
		</mrow>
		<mo>)</mo>
	</mrow></math>
	ok just make a "complement if [condition]" syntax
	
	
	tilemap texture origin onscreen (spx relative to origin) = ((ipart - fpart/64) tpx + 18 tpx ) * inv scale (spx/tpx) + 22 spx
	
	input: spx offset
	output: tpx offset
	
	(x index - 22 spx) * scale (tpx/spx) - 18 tpx = (ipart - fpart/64) tpx
	ugh what does that even mean
	
	uh we need to calculate a correction factor uhhhhh.  
	well ok first lets say.  what is the number of texture pixels per screen pixel
	that would be, the scale. (after the unit conversion to tpx/spx)
	so. for each +1 spx, we must add, +1 spx * scale
	
	
	screen pixel position of texture column X (spx relative to origin) = ((ipart - fpart/64) tpx + 18 tpx ) / scale (tpx/spx) + 22 spx + (X / scale) (spx)
	
	(screen pixel position of texture column X (spx relative to origin) - (((ipart - fpart/64) tpx + 18 tpx ) / scale (tpx/spx) + 22 spx))*scale = X
	
	(
	screen pixel position of texture column X * scale -
	(((ipart - fpart/64) tpx + 18 tpx ) / scale (tpx/spx) + 22 spx) * scale
	) = X
	
	(
	screen pixel position of texture column X * scale -
	((ipart - fpart/64) tpx + 18 tpx ) (tpx/spx) -
	22 spx * scale
	) = X
	

	
	(
	(screen pixel position of texture column X - 22 spx) * scale -
	((ipart - fpart/64) tpx + 18 tpx)
	) = X
	
	thusly: 
	
	texture x = (screen x - 22 screen pixels) * scale - scroll + 18 texture pixels
