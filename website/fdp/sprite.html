<!doctype html>

<link rel=stylesheet href=../style.css>
<link rel=stylesheet href=./style2.css>
<script src=f3-bits.js></script>

<h1>Sprites</h1>

<p>The <abbr>fdp</abbr> renders up to ~900 sprites per frame to a single bitmap framebuffer.&nbsp;
	Each sprite uses a 16Ã—16 texture from <abbr>rom</abbr>, with up to 64 colors each (including transparent).
	
<p>Sprites are split into four "groups", depending on the 2 uppermost bits of their palette.&nbsp;
	Sprites in higher group numbers render in front of lower ones.&nbsp;
	Within a group, later sprites render in front of earlier ones. <todo>i think?</todo>
	Note: this is a separate priority system from the one used later. e.g. <todo>(give an example like, 2 sprites with a tilemap between them in priority, but with reversed draw order so the back one clips the upper one)</todo>
	<todo>we have to explain sprite groups in the beginning part, because they matter during rendering (for drawing priority) and displaying (for per-group lineram settings), while in general most aspects of sprites do NOT apply to both</todo>
	
<h2>The Sprite Layer</h2>
<p>The sprite framebuffer is used as the source for the Sprite Layer.
<p>Some of the sprite layer's common layer settings can be set per-group (Priority, Blend Mode, and Alpha Select).&nbsp;
	In some ways, it acts like 4 separate sprite layers, but note that sprites can never blend with each other because they share a single framebuffer.
	
<figure class=f3-struct>
	<h1>Line Register 2.0 "6000"</h1>
	<f3-bits>#:8,s<sub>3</sub>:2,s<sub>2</sub>:2,s<sub>1</sub>:2,s<sub>0</sub>:2</f3-bits>
	<dl class=bits>
		<dt>s<sub>N</sub><dd>Sprite Layer, Group <var>N</var>: Blend Mode
			<dl><dt>0<dd>none<dt>1<dd>A<dt>2<dd>B<dt>3<dd>A+B</dl>
	</dl>
</figure>

<figure class=f3-struct>
	<h1>Line Register 2.2 "6400"</h1>
	<f3-bits>#:7,s,#:4,#:4</f3-bits>
	<dl class=bits>
		<dt>s<dd>Sprite Layer: Mosaic Enable
	</dl>
</figure>

<figure class=f3-struct>
	<h1>Line Register 3.2 "7400"</h1>
	<f3-bits>s<sub>3</sub>,s<sub>2</sub>,s<sub>1</sub>,s<sub>0</sub>,?,?,E,I,c<sub>3</sub>,c<sub>2</sub>,c<sub>1</sub>,c<sub>0</sub>,i<sub>3</sub>,i<sub>2</sub>,i<sub>1</sub>,i<sub>0</sub></f3-bits>
	<dl class=bits>
		<dt>i<sub>n</sub><dd>Sprite Layer: Clip Plane <var>n</var> Mode
		<dt>c<sub>n</sub><dd>Sprite Layer: Clip Plane <var>n</var> Enable
		<dt>I<dd>Sprite Layer: Clip Invert
		<dt>E<dd>Sprite Layer: Enable
		<dt>s<sub>N</sub><dd>Sprite Layer, Group <var>N</var>: Alpha Select
	</dl>
</figure>

<figure class=f3-struct>
	<h1>Line Register 3.3 "7600"</h1>
	<f3-bits>prio<sub>3</sub>:4,prio<sub>2</sub>:4,prio<sub>1</sub>:4,prio<sub>0</sub>:4</f3-bits>
	<dl class=bits>
		<dt>prio<sub>N</sub><dd>Sprite Layer, Group <var>N</var>: Priority (0-15)
	</dl>
</figure>
	
<h2>Sprite Rendering</h2>
<p>Sprites are rendered from Sprite Ram, which contains 4 banks of 1024 entries each.&nbsp;
	Each entry consists of eight 16-bit values, and represents one sprite (and/or a command that sets graphics parameters, and/or set the scroll positions, and/or jump destination <todo></todo>).&nbsp;
	On each frame the FDP iterates over the sprite entries, starting at index 0 of the current bank (but the current index and bank can be changed using commands and jumps).

<p>Individual sprites can be tiled into larger blocks by using the Block Controls.
	
<p>There are two scroll values, which we call "global" and "subglobal".&nbsp;
	These can be changed at any time, and you can choose which ones (global only, global+subglobal, or neither) to use for each sprite.
	
<p>Note that sprite rendering itself is not affected by any lineram settings.
	
	<todo>explain command mode better. note the consequences of setting it on a visible sprite (field 5's value is used for 2 things at once)</todo>
	
<p>
	The order of operations when processing a sprite entry is:<br>
<ol>
	<li>read position from sprite ram
	<li>process Set Scrolls (modifying scrolls)
	<li>process Enable Scrolls (adding scrolls to position)
	<li>process Multi (setting block origin, reading zoom)
	<li>process X Block Control and Y Block Control (overriding x and/or y position)
	<li>(read the palette, texture id, flip etc.)
	<li>render the sprite
	<li>save the positions of the left/right/bottom edges of the sprite
	<li>process Jump (choosing the next sprite index)
	<li>process commands ? (setting the bank, etc.) <todo>does this take effect at the very end, or sometime during the current sprite entry?</todo>
</ol>
<todo>change our styling so that instead of styling &lt;p> we style &lt;section> or something</todo>
	
<figure class="f3-struct">
	<h1>Sprite Ram Entry</h1>
	<h2>Address</h2>
	<f3-bits>&ctdot;,0,0,0,bank:2,index:10,w:3,-</f3-bits>
	<dl class=bits>
		<dt>bank<dd>bank number (set by command)
		<dt>index<dd>sprite index
		<dt>w<dd>field number
	</dl>
</figure>
<figure class="f3-struct">
	<h1>Sprite Field 0</h1>
	<h2>Data</h2>
	<f3-bits>texture:16</f3-bits>
	<dl class=bits>
		<dt>texture<dd>Texture Id (lower bits)
	</dl>
</figure>
z/128 = 15/16
<figure class="f3-struct">
	<h1>Sprite Field 1</h1>
	<h2>Data</h2>
	<f3-bits>yzoom:8,xzoom:8</f3-bits>
	<dl class=bits>
		<dt>xzoom<dd>X Zoom<br><div class=mathbox>X Zoom (in screen pixels per texture pixel) = 1 &minus; xzoom/256</div><br>
			Example sizes:<br>
			<dl><dt>$00<dd>16px<dt>$40<dd>12px<dt>$80<dd>8px<dt>$C0<dd>4px<dt>$FF<dd>0.0625px</dl>
		<dt>yzoom<dd>Y Zoom (same format as X)<br>
			<todo>iirc, one axis is positioned with subpixel precision while the other isn't. they're also downscaled differently (even though the actual zoom values are the same) check which is which</todo>
	</dl>
</figure>
<figure class="f3-struct">
	<h1>Sprite Field 2</h1>
	<h2>Data</h2>
	<f3-bits>i:2,s:2,x:12</f3-bits>
	<dl class=bits>
		<dt>x<dd>X Position (in screen pixels)<br>
		<dt>s<dd>Set Scrolls: which scroll values to write the position to
			<dl><dt>0<dd>(none)<dt>1<dd>subglobal<dt>2<dd>global<dt>3<dd>global and subglobal</dl>
		<dt>i<dd>Enable Scrolls: which scroll values to add to the position
			<dl><dt>0<dd>global and subglobal<dt>1<dd>global<dt>2<dd>global and subglobal (yes, really)<dt>3<dd>(none)</dl>
	</dl>
</figure>
<figure class="f3-struct">
	<h1>Sprite Field 3</h1>
	<h2>Data</h2>
	<f3-bits>c,?:3,y:12</f3-bits>
	<dl class=bits>
		<dt>y<dd>Y Position (same format as X)<br>
		<dt>c<dd>"Command":<dl><dt>0<dd>normal<dt>1<dd>write the contents of field 5 to the Sprite Settings register</dl>
	</dl>
</figure>
<figure class="f3-struct">
	<h1>Sprite Field 4</h1>
	<h2>Data</h2>
	<f3-bits>x:2,?,y,M,p,v,h,pal:8</f3-bits>
	<dl class=bits>
		<dt>pal<dd>Palette Id (256-511) = 256 + pal<br>
		<dt>h<dd><dl compact><dt>1<dd>horizontal flip</dl>
		<dt>v<dd><dl compact><dt>1<dd>vertical flip</dl>
		<dt>p<dd>palette lock<dl><dt>1<dd>reuse palette from previous sprite<dt>0<dd>use new palette</dl>
		<dt>M<dd>"Multi" - <u>this bit affects the next sprite, not the current one</u><dl><dt>0<dd>write the current position to the Y Block Origin, and read the zoom values<dt>1<dd>don't</dl>
		<dt>y<dd>Y Block Control - set y position to:<dl><dt>0<dd>Y Block Origin (note: if Multi was 0, this will be the current position)<dt>1<dd>below previous sprite</dl>
		<dt>x<dd>X Block Control - set x position to:<dl><dt>0<dd>current position<dt>1<dd>same as previous sprite<dt>2<dd>right of previous sprite, except first row renders at current position<dt>3<dd>right of previous sprite</dl>
			There are effectively 6 possible combinations of x and y block controls:<br>
			(note: in this chart, the left side is the given x position, and the top side is the y block origin)
			<img src=sprite-tess.svg width=175 height=180 style=background:white><br>
			Note that sprite blocks are intended be in column-major order, because there is no way to position a sprite directly to the right of the previous one.&nbsp;<br>
			Generally, games only use rectangular sprite blocks, using 3 combinations of block controls:<br>
			(0,0) for the first sprite in the block (along with setting multi=0 on the previous sprite)<br>
			(3,0) for the first sprite in each subsequent column<br>
			(1,1) for the rest of the sprites<br>
			Typical 3x3 sprite block, showing the order of the sprites and their block controls (as color):<br>
			<img src=sprite-tess2.svg width=175 height=180 style=background:white><br>
			Only the first sprite (red) has a positon set in ram.&nbsp;<br>
			<todo>clean this up and also show the actual sprite ram values for the example</todo>
	</dl>
</figure>
<figure class="f3-struct">
	<h1>Sprite Field 5</h1>
	<h2>Data</h2>
	<f3-bits>.:8,fmt:4,?,?,tex2:2</f3-bits>
	<dl class=bits>
		<dt>tex2<dd>Texture Id (upper bits) - this might be more than 2 bits
		<dt>fmt<dd>bitmap format? - <todo>affects the order of pixels loaded from rom?</todo>
	</dl>
	note: this value of this field is reused to set the sprite settings register.
</figure>
<figure class="f3-struct">
	<h1>Sprite Field 6</h1>
	<h2>Data</h2>
	<f3-bits>j,.:5,dest:10</f3-bits>
	<dl class=bits>
		<dt>dest<dd>jump destination
		<dt>j<dd>Jump: determines next sprite index:<dl><dt>1<dd>jump to dest<dt>0<dd>current index + 1</dl>
	</dl>
</figure>
<figure class="f3-struct">
	<h1>Sprite Field 7</h1>
	(unused?)
</figure>

<figure class="f3-struct">
	<h1>Sprite Settings</h1>
	(set by a "Command" sprite)
	<h2>Data</h2>
	<f3-bits>?,?,k,j,?,b<sub>0</sub>,g,f,?,a:3,?,?,t,b<sub>1</sub></f3-bits>
	<dl class=bits>
		<dt>b<sub>1</sub><dd>spriteram bank number (upper bit)
		<dt>t<dd><todo>supposedly disables clearing framebuffer but seems to be something else</todo>
		<dt>a<dd><todo>affects visiblity of sprites or something</todo>
		<dt>f<dd><todo>sets palettes to 0(?), and then adds some garbage pixels around the sprites which do a palette offset? not sure where these come from, they seem consistent?</todo>
		<dt>g<dd><todo>similar to f but different</todo>
		<dt>b<sub>0</sub><dd>spriteram bank number (lower bit)
		<dt>j<dd><todo>changes video signal (causes us to lose sync, but definitely still outputting a picture)</todo>
		<dt>k<dd>1 = flipscreen
	</dl>
</figure>
