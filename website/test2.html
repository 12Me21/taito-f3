<!doctype html>

<style>
	f3-bits, f3-struct dt {
		font-family: courier, monospace;
		word-spacing: -0.25ch;
		font-size: 1.25em;
		line-height: 22px;
	}
	f3-struct, f3-addr, f3-data {
		display: flex;
		flex-direction: column;
	}
	f3-struct {
		margin-bottom: 1em;
	}
	f3-bits {
		border: 2px inset;
		display: inline-block;
		padding: 0 0.5ch;
		white-space: pre-wrap;
		align-self: flex-start;
	}
	f3-bits >* {
		font-weight: normal;
	}
	f3-bits b:nth-child(2n) {
		color: red;
	}
	f3-struct {
		border-left: solid black;
		padding: 0.5em 0 0.5em 1em;
	}
	f3-struct dt {
		margin-right: 0.5em;
		justify-self: right;
	}
	f3-struct dt::after {
		content: ":";
		font-weight: normal;
	}
	f3-struct dl {
		display: grid;
		grid: auto-flow / max-content 1fr;
		margin-left: 1em;
		margin-top: 0.25em;
		margin-bottom: 0em;
	}
	f3-struct f3-addr dl {
		margin-bottom: 0.5em;
	}
	f3-struct dl>* {
		align-self: baseline;
	}
	f3-struct dd {
		margin: 0;
	}
	f3-struct h1 {
		margin: 0;
		font-size: 1.5em;
		margin-bottom: 0.5em;
		margin-left: -0.25em;
	}
	f3-struct f3-addr h1, f3-struct f3-data h1 {
		font-size: 1.2em;
		margin: 0;
	}
	f3-struct dl dl {
		margin-left: 0;
		margin-top: 0;
		margin-bottom: 0;
	}
	f3-struct dl dl dt {
		font-size: unset;
	}
	dl.compact {
		display: flex;
		flex-wrap: wrap;
	}
	dl.compact > dd:not(:last-child) {
		margin-right: 1em;
	}
	dl.compact > dt {
		margin-right: 0em;
	}
	dl.compact > dt::after {
		content: "=";
	}
</style>

<p>to help you get your bearings, here is an overview of the layout of graphics ram: (todo: baby mode table)</p>

<p>There are four playfields consisting of a 32x32 or 64x32 grid of 16x16px tiles.</p>

<f3-struct>
	<h1>Playfield Tile</h1>
	<f3-addr>
		<h1>Address</h1>
		<div><f3-bits>&ctdot; 01 0nnn yyyy yxxx xx--</f3-bits> (normal)</div>
		<div><f3-bits>&ctdot; 01 nnny yyyy xxxx xx--</f3-bits> (extend mode)</div>
		<dl>
			<dt>n<dd>playfield index
				<dl>
					<dt>0,1,2,3<dd>regular playfield data
					<dt>4,5<dd>alternate data for playfields 2 and 3
				</dl>
			<dt>y<dd>y index (0-31)
			<dt>x<dd>x index (0-31 or 0-64)
		</dl>
	</f3-addr>
	<f3-data>
		<h1>Data</h1>
		<f3-bits>hvTT ppsc cccc cccc  tttt tttt tttt tttt</f3-bits>
		<dl>
			<dt>t<dd>tile index (lower bits)
			<dt>c<dd>palette (0-511)
			<dt>s<dd>blend select
			<dt>p<dd>texture bit planes (bits per pixel select)
				<dl class=compact>
					<dt>0<dd>4bpp
					<dt>1<dd>5bpp
					<dt>2<dd>?
					<dt>3<dd>6bpp
				</dl>
			<dt>T<dd>tile index (upper bits)
			<dt>v<dd>vertical flip
			<dt>h<dd>horizontal flip
		</dl>
	</f3-data>
</f3-struct>

<p>the pivot layer is a 64x64 grid of 8x8 tiles, which gets its textures from RAM instead of ROM. it can either be in "text mode" (where the texture is looked up based on the tile's id) or "pixel mode" (where each cell has a unique texture, whose address depends on its position in the grid, effectively giving you a 512x256 bitmap, though the pixels are in a weird order)</p>

<f3-struct>
	<h1>Text Tile</h1>
	<f3-addr>
		<h1>Address</h1>
		<f3-bits>&ctdot; 01 110y yyyy yxxx xxx-</f3-bits>
		<dl>
			<dt>y<dd>y index (0-63)
			<dt>x<dd>x index (0-63)
		</dl>
	</f3-addr>
	<f3-data>
		<h1>Data</h1>
		<f3-bits>hccc cccv tttt tttt</f3-bits>
		<dl>
			<dt>t<dd>tile index (0-255)
			<dt>v<dd>vertical flip
			<dt>c<dd>palette (0-63)
			<dt>h<dd>horizontal flip
		</dl>
	</f3-data>
</f3-struct>

<f3-struct>
	<h1>Text Glyph</h1>
	<f3-addr>
		<h1>Address</h1>
		<f3-bits>&ctdot; 01 111t tttt ttt- ----</f3-bits>
		<dl>
			<dt>t<dd>tile index (0-255)
		</dl>
	</f3-addr>
	<f3-data>
		<h1>Data</h1>
		<div><f3-bits>bbbb bbbb bbbb bbbb bbbb bbbb bbbb bbbb</f3-bits> × 8</div>
		<dl>
			<dt>b<dd>8×8 bitmap, 4 bits per pixel
		</dl>
	</f3-data>
</f3-struct>

<p>pixel mode is similar to text mode, but the data for each tile is fetched based on the tile's position rather than the tile index in the text data.</p>

<f3-struct>
	<h1>Pixel Data Cell</h1>
	<f3-addr>
		<h1>Location:</h1>
		<f3-bits>&ctdot; 1b xxxx xxyy yyy- ----</f3-bits>
		<dl>
			<dt>b<dd>bank
			<dt>x<dd>x index (0-63)
			<dt>y<dd>y index (0-31)
		</dl>
	</f3-addr>
	<f3-data>
		<h1>Data</h1>
		<div><f3-bits>bbbb bbbb bbbb bbbb bbbb bbbb bbbb bbbb</f3-bits> × 8</div>
		<dl>
			<dt>b<dd>8×8 bitmap, 4 bits per pixel
		</dl>
	</f3-data>
</f3-struct>

<f3-struct>
	<h1>common layer properties</h1>
	<dl class=>
		<dt>display enable<dd><dl class=compact><dt>0<dd>off<dt>1<dd>on</dl>(todo: hm does disabling turn off the updating of y position based on scale?)
		<dt>priority<dd>0-15. higher = above other things. two layers with the same priority can cause a conflict.
		<dt>clip invert<dd><dl class=compact><dt>0<dd>normal<dt>1<dd>inverted</dl>
		<dt>clip plane enable ×4<dd>one per clip plane<dl class=compact><dt>0<dd>off<dt>1<dd>on</dl>
		<dt>clip plane mode ×4<dd>one per clip plane<dl class=compact><dt>0<dd>hide inside<dt>1<dd>hide outside</dl>
		<dt>blend mode<dd>which half-pixel(s) to contribute to. encoding varies by layer
		<dt>blend select<dd>which of the 2 possible blend values will be used for a given half-pixel
		<dt>mosaic enable<dd><dl class=compact><dt>0<dd>off<dt>1<dd>on</dl>
	</dl>
</f3-struct>
	
<f3-struct>
	<h1>Section 7.0 ("B000")</h1>
	<f3-data>
		<f3-bits>BBEI cccc iiii pppp</f3-bits>
		<dl>
			<dt>p<dd><i>playfield 0</i> <i>priority</i> (0-15)
			<dt>i<dd><i>playfield 0</i> <i>clip interval modes</i>
			<dt>c<dd><i>playfield 0</i> <i>clip interval enables</i>
			<dt>I<dd><i>playfield 0</i> <i>clip invert</i>
			<dt>E<dd><i>playfield 0</i> <i>enable</i>
			<dt>B<dd><i>playfield 0</i> <i>blend mode</i>
		</dl>
	</f3-data>
	
	
[]
 p - {playfield 0} priority
 iiii - {playfield 0} clip modes: 0 = hide inside, 1 = hide outside
 cccc - {playfield 0} 1 = enable clip plane
 I - {playfield 0} 1 = invert clipping
 E - {playfield 0} 1 = enable display
 B - {playfield 0} blend mode. 0=both, 1=left, 2=right, 3=neither
"B200" (7.1)
- same for {playfield 1}
"B400" (7.2)
- same for {playfield 2}
"B600" (7.3)
- same for {playfield 3}
</f3-struct>

<script>
	for (let e of document.querySelectorAll('f3-bits')) {
		e.innerHTML = e.innerHTML.replace(/([a-zA-Z])( ?\1)*/g, "<b>$&</b>")
	}
</script>
